<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>dsa个人题库 | Andy's blog</title><meta name="author" content="Andy"><meta name="copyright" content="Andy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文是作者在复习数据结构刷题的时候遇到的简单但不完全简单的小题（大题的话博主已经弃疗了…要杀要刮随邓公了）。dsa知识点相当的多，随便举一些例子吧：主定理、动态规划、向量列表、先序遍历的递归&#x2F;迭代版、AVL树和红黑树、散列冲突、dijkstra、堆合并、KMP算法、各种各样的排序（以及它们的性质和改进）… 总之，这些题目是巩固理解、记牢算法的好选择，而难度较大的证明大题则超出了博主的理解">
<meta property="og:type" content="article">
<meta property="og:title" content="dsa个人题库">
<meta property="og:url" content="http://example.com/2023/04/02/dsa/index.html">
<meta property="og:site_name" content="Andy&#39;s blog">
<meta property="og:description" content="本文是作者在复习数据结构刷题的时候遇到的简单但不完全简单的小题（大题的话博主已经弃疗了…要杀要刮随邓公了）。dsa知识点相当的多，随便举一些例子吧：主定理、动态规划、向量列表、先序遍历的递归&#x2F;迭代版、AVL树和红黑树、散列冲突、dijkstra、堆合并、KMP算法、各种各样的排序（以及它们的性质和改进）… 总之，这些题目是巩固理解、记牢算法的好选择，而难度较大的证明大题则超出了博主的理解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.bliner.me/2018-12-13-15446748009361.png?imageView2/0/q/100|watermark/1/image/aHR0cDovL2ltYWdlLmJsaW5lci5tZS9ibGluZXJ3YXRlcm1hcmsucG5n/dissolve/40/gravity/SouthWest/dx/10/dy/10|imageslim">
<meta property="article:published_time" content="2023-04-02T08:07:38.342Z">
<meta property="article:modified_time" content="2023-04-02T12:35:38.111Z">
<meta property="article:author" content="Andy">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.bliner.me/2018-12-13-15446748009361.png?imageView2/0/q/100|watermark/1/image/aHR0cDovL2ltYWdlLmJsaW5lci5tZS9ibGluZXJ3YXRlcm1hcmsucG5n/dissolve/40/gravity/SouthWest/dx/10/dy/10|imageslim"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/02/dsa/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'dsa个人题库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-02 20:35:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Andy's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://image.bliner.me/2018-12-13-15446748009361.png?imageView2/0/q/100|watermark/1/image/aHR0cDovL2ltYWdlLmJsaW5lci5tZS9ibGluZXJ3YXRlcm1hcmsucG5n/dissolve/40/gravity/SouthWest/dx/10/dy/10|imageslim')"><nav id="nav"><span id="blog-info"><a href="/" title="Andy's blog"><span class="site-name">Andy's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">dsa个人题库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-02T08:07:38.342Z" title="发表于 2023-04-02 16:07:38">2023-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-02T12:35:38.111Z" title="更新于 2023-04-02 20:35:38">2023-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="dsa个人题库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文是作者在复习数据结构刷题的时候遇到的简单但不完全简单的小题（大题的话博主已经弃疗了…要杀要刮随邓公了）。dsa知识点相当的多，随便举一些例子吧：主定理、动态规划、向量列表、先序遍历的递归&#x2F;迭代版、AVL树和红黑树、散列冲突、dijkstra、堆合并、KMP算法、各种各样的排序（以及它们的性质和改进）…</p>
<p>总之，这些题目是巩固理解、记牢算法的好选择，而难度较大的证明大题则超出了博主的理解范围…假若将来博主需要复习dsa，或者真的有学弟学妹会看到这篇题库，那么希望这些题目能对将来的我&#x2F;别人有一丁点帮助…</p>
<h3 id="1、对于二分查找版本C，当查找区间的长度缩小为0时，V-lo-是："><a href="#1、对于二分查找版本C，当查找区间的长度缩小为0时，V-lo-是：" class="headerlink" title="1、对于二分查找版本C，当查找区间的长度缩小为0时，V[lo]是："></a>1、对于二分查找版本C，当查找区间的长度缩小为0时，V[lo]是：</h3><p>min{0 &lt; r &lt; n|e &lt; V[r]}。因为<strong>事实上命中的秩是lo-1</strong>，而lo-1右边的（也就是从lo开始的左闭右开区间）都是严格大于e的元素。故而V[lo]是大于e的，而v[lo-1]不大于e。顺便一提，向量中的lo和hi永远是左闭右开区间，即[lo，hi）。</p>
<h3 id="2、在有序向量V中插入元素e并使之保持有序，下列代码正确的是"><a href="#2、在有序向量V中插入元素e并使之保持有序，下列代码正确的是" class="headerlink" title="2、在有序向量V中插入元素e并使之保持有序，下列代码正确的是:"></a>2、在有序向量V中插入元素e并使之保持有序，下列代码正确的是:</h3><p>V.insert(V.Search(e)+1,e)。V.Search(e)应当+1，否则会将最后一个元素挤掉。</p>
<h3 id="3、是否可以将视频里向量扩容代码中的："><a href="#3、是否可以将视频里向量扩容代码中的：" class="headerlink" title="3、是否可以将视频里向量扩容代码中的："></a>3、是否可以将视频里向量扩容代码中的：</h3><h5 id="for-int-i-0-i-lt-size-i-elem-i-oldElem-i"><a href="#for-int-i-0-i-lt-size-i-elem-i-oldElem-i" class="headerlink" title="for (int i = 0; i &lt; _size; i++) _elem[i] = oldElem[i];"></a><code>for (int i = 0; i &lt; _size; i++) _elem[i] = oldElem[i];</code></h5><h5 id="替代为："><a href="#替代为：" class="headerlink" title="替代为："></a>替代为：</h5><h5 id="memcpy-elem-oldElem-size-sizeof-T"><a href="#memcpy-elem-oldElem-size-sizeof-T" class="headerlink" title="memcpy(_elem, oldElem, _size * sizeof(T));"></a><code>memcpy(_elem, oldElem, _size * sizeof(T));</code></h5><p>不可以，与T的数据类型有关。简单地说，假如T不是基本数据类型例如string或一个类，那么&#x3D;号或许是重载过的，<strong>前者相当于深拷贝；而memcpy是浅拷贝</strong>（假如你去查memcpy的源代码的话会发现它就是在逐字节地复制hhhh），析构的时候可能会报错！</p>
<h3 id="4、用分而治之的思想来解决长度为n的数组的求和问题（n足够大），递归实例的数目会比用减而治之的方法少。"><a href="#4、用分而治之的思想来解决长度为n的数组的求和问题（n足够大），递归实例的数目会比用减而治之的方法少。" class="headerlink" title="4、用分而治之的思想来解决长度为n的数组的求和问题（n足够大），递归实例的数目会比用减而治之的方法少。"></a>4、用分而治之的思想来解决长度为n的数组的求和问题（n足够大），递归实例的数目会比用减而治之的方法少。</h3><p>错，在这个问题上，分而治之和减而治之的效率相同，时间复杂度均为O(n)。</p>
<h3 id="5、直接用定义以递归的方式计算fib-n-的时间复杂度是Θ-2-n-："><a href="#5、直接用定义以递归的方式计算fib-n-的时间复杂度是Θ-2-n-：" class="headerlink" title="5、直接用定义以递归的方式计算fib(n)的时间复杂度是Θ(2^n)："></a>5、直接用定义以递归的方式计算fib(n)的时间复杂度是Θ(2^n)：</h3><p>错，实际上时间复杂度是Θ(1.618^n)，故而只能说**是O(2^n)而非θ(2^n)**。</p>
<h3 id="6、在向量V-x3D-2-3-5-7-11-13-17-19-23-中用插值查找搜索元素7，猜测的轴点mi为："><a href="#6、在向量V-x3D-2-3-5-7-11-13-17-19-23-中用插值查找搜索元素7，猜测的轴点mi为：" class="headerlink" title="6、在向量V&#x3D;{2, 3, 5, 7, 11, 13, 17, 19, 23}中用插值查找搜索元素7，猜测的轴点mi为："></a>6、在向量V&#x3D;{2, 3, 5, 7, 11, 13, 17, 19, 23}中用插值查找搜索元素7，猜测的轴点mi为：</h3><p>答案为1。*<em>mi&#x3D;lo+(hi-lo)</em>(e-V[lo])&#x2F;(V[hi]-V[lo])**。</p>
<h3 id="7、长度为n的列表，被等分为n-x2F-k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为："><a href="#7、长度为n的列表，被等分为n-x2F-k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为：" class="headerlink" title="7、长度为n的列表，被等分为n&#x2F;k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为："></a>7、长度为n的列表，被等分为n&#x2F;k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为：</h3><p>O(n k)。插入排序的时间复杂度&#x3D;O(n+I)，其中I为逆序对（不是相邻逆序对）的数量。本题中最多有 n &#x2F; k * k^2&#x3D; n * k个逆序对。</p>
<p>顺便一提，<strong>逆序对与插入排序相关，而循环节与选择排序相关</strong>（循环节的数量决定了选择排序中“无效交换”的次数，期望为θ(log n) ）。</p>
<h3 id="8、（在中缀表达式求值中）什么时候进行实际的运算？"><a href="#8、（在中缀表达式求值中）什么时候进行实际的运算？" class="headerlink" title="8、（在中缀表达式求值中）什么时候进行实际的运算？"></a>8、（在中缀表达式求值中）什么时候进行实际的运算？</h3><p>当前的操作符比栈顶的操作符优先级低时，即栈顶运算符优先级高时。因为每次运算都是对于栈顶运算符的运算。</p>
<h3 id="9、在一棵树中-顶点p是顶点v的父亲-则它们的高度的关系是否为height-v-x3D-height-p-1？"><a href="#9、在一棵树中-顶点p是顶点v的父亲-则它们的高度的关系是否为height-v-x3D-height-p-1？" class="headerlink" title="9、在一棵树中,顶点p是顶点v的父亲,则它们的高度的关系是否为height(v)&#x3D;height(p)-1？"></a>9、在一棵树中,顶点p是顶点v的父亲,则它们的高度的关系是否为height(v)&#x3D;height(p)-1？</h3><p>不一定，比如p的左孩子是v，右孩子有一棵很大的子树，此时height(v)&#x3D;0而height(p)&#x3D;k。故而只能说height(v)&lt;height(p)。</p>
<h3 id="10、对以下二叉树进行先序遍历，刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为"><a href="#10、对以下二叉树进行先序遍历，刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为" class="headerlink" title="10、对以下二叉树进行先序遍历，刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为:"></a>10、对以下二叉树进行先序遍历，刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为:</h3><p><img src="/2023/04/02/dsa/1.jpg"></p>
<p>只有f。</p>
<p>事实上，“沿藤爬取”算法会先访问该节点，再将该节点的右孩子推入栈，并顺左侧藤下行。主算法会试图对每次调用“沿藤爬取”算法，并在无法继续爬取后将栈顶pop掉，再次对该元素进行爬取。</p>
<p>故而首先对a爬取，访问a，将c压栈，再访问b。此时“沿藤爬取”算法结束，将c pop掉并沿c爬取，访问c，将f压栈，再访问d，再将e压栈。故而刚访问完d的时候栈中只有c的右孩子f。</p>
<h3 id="12、对以下二叉树进行中序遍历，节点c刚被访问完毕时栈中的元素从栈顶到栈底为"><a href="#12、对以下二叉树进行中序遍历，节点c刚被访问完毕时栈中的元素从栈顶到栈底为" class="headerlink" title="12、对以下二叉树进行中序遍历，节点c刚被访问完毕时栈中的元素从栈顶到栈底为:"></a>12、对以下二叉树进行中序遍历，节点c刚被访问完毕时栈中的元素从栈顶到栈底为:</h3><p><img src="/2023/04/02/dsa/6a847e3de9105b2fa947e777fad2235.jpg"></p>
<p>d和f。</p>
<p>中序遍历时，“沿藤爬取”算法会将每个节点入栈，直到爬完为止。回到主算法，算法会pop掉栈顶元素并访问它，同时试图进入它的右孩子。若有右孩子，则以右孩子为根实施“沿藤爬取”算法，若没有右孩子，则会再pop掉栈顶元素，以此为根实施“沿藤爬取”算法。</p>
<p>故而首先对b爬取，b入栈，a入栈，访问a，访问b，并且转向其右孩子f，对f进行爬取会将f，d，c入栈，访问c。</p>
<h3 id="13、对以下二叉树进行层次遍历，节点F正欲出队时队列中的元素从队头到队尾为"><a href="#13、对以下二叉树进行层次遍历，节点F正欲出队时队列中的元素从队头到队尾为" class="headerlink" title="13、对以下二叉树进行层次遍历，节点F正欲出队时队列中的元素从队头到队尾为:"></a>13、对以下二叉树进行层次遍历，节点F正欲出队时队列中的元素从队头到队尾为:</h3><p><img src="/2023/04/02/dsa/4575cfc47ab97c73e4b59c1401d8064.jpg"></p>
<p>f和g。</p>
<p>请注意，层次遍历使用的辅助数据结构不是栈，而是队列。也没有藤算法，只有一个主算法。主算法会将根入队，并且每次循环将队首出队并访问，并将其左孩子入队、右孩子入队。</p>
<p>访问A，将B入队。访问B，将C和D依次入队…本算法比先序中序容易很多。</p>
<h3 id="14、从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，最坏时间复杂度为O-n-？"><a href="#14、从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，最坏时间复杂度为O-n-？" class="headerlink" title="14、从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，最坏时间复杂度为O(n)？"></a>14、从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，最坏时间复杂度为O(n)？</h3><p>正确，因为极端退化的二叉树就是链表（即所有节点都只有一个孩子），BST也是一样的。</p>
<h3 id="15、AVL树插入节点最多会使多少节点失衡？删除节点呢？"><a href="#15、AVL树插入节点最多会使多少节点失衡？删除节点呢？" class="headerlink" title="15、AVL树插入节点最多会使多少节点失衡？删除节点呢？"></a>15、AVL树插入节点最多会使多少节点失衡？删除节点呢？</h3><p>O(log n)和O(1)。事实上，删除节点至多只会令一个节点失衡。</p>
<p>值得一提的是，插入节点后失衡的节点最低为其祖父（爷爷），而删除节点后失衡的节点最低可以是其父亲。但在调整时，插入导致的失衡只需一次单旋&#x2F;双旋即可，而删除导致的失衡却可能需要至多O(log n)次单旋&#x2F;双旋。</p>
<h3 id="16、AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g-p-v的子树高度"><a href="#16、AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g-p-v的子树高度" class="headerlink" title="16、AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度"></a>16、AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度</h3><p>有可能不变也有可能减小1。请注意这里的子树高度是相比于原AVL树而言，即删除操作之前的树。如果子树高度不变，那么全树复衡；高度减1，则需要向上继续旋转。</p>
<p>顺便一说，插入节点后旋转，其子树高度一定不变，这也对应了上一个问题中所说的，插入后只需一次单旋&#x2F;双旋。</p>
<h3 id="17、伸展树采用双层伸展策略，即可避免最坏情况的发生？"><a href="#17、伸展树采用双层伸展策略，即可避免最坏情况的发生？" class="headerlink" title="17、伸展树采用双层伸展策略，即可避免最坏情况的发生？"></a>17、伸展树采用双层伸展策略，即可避免最坏情况的发生？</h3><p>错误。【这道题有点文字游戏…】只能减小最坏情况的频率，也就是最坏情况不致持续发生，但仍可能极少地发生。</p>
<h3 id="18、如果说访问一次内存需要1秒，则一次外存访问大概需要："><a href="#18、如果说访问一次内存需要1秒，则一次外存访问大概需要：" class="headerlink" title="18、如果说访问一次内存需要1秒，则一次外存访问大概需要："></a>18、如果说访问一次内存需要1秒，则一次外存访问大概需要：</h3><p>一天。访问内存需要100 ns，而磁盘访问需要10^7 ns。两者相差10^5倍。</p>
<h3 id="19、教材P-802的重散列（rehash）一定是扩容操作吗？"><a href="#19、教材P-802的重散列（rehash）一定是扩容操作吗？" class="headerlink" title="19、教材P 802的重散列（rehash）一定是扩容操作吗？"></a>19、教材P 802的重散列（rehash）一定是扩容操作吗？</h3><p>不一定。如果懒惰删除的标记太多，那么4 N（其中N是当前真实的非空桶，不包括懒惰删除标记）不一定比当前散列表的长度大，此时的重散列反而是缩容操作。这也是为什么我们不用2 M（M是散列表长度）而用4 N的原因。</p>
<h3 id="20、红黑树在每次插入-x2F-删除操作后，拓扑结构的变化不超过O-1-。"><a href="#20、红黑树在每次插入-x2F-删除操作后，拓扑结构的变化不超过O-1-。" class="headerlink" title="20、红黑树在每次插入&#x2F;删除操作后，拓扑结构的变化不超过O(1)。"></a>20、红黑树在每次插入&#x2F;删除操作后，拓扑结构的变化不超过O(1)。</h3><p>正确。事实上，这是红黑树非常重要的性质之一。而AVL树虽然插入操作满足题意，但正如16题所说，删除操作可能会有O(log n)级别的拓扑改变。</p>
<h3 id="21、所有AVL树可以染成红黑树，所有红黑树都是AVL树。"><a href="#21、所有AVL树可以染成红黑树，所有红黑树都是AVL树。" class="headerlink" title="21、所有AVL树可以染成红黑树，所有红黑树都是AVL树。"></a>21、所有AVL树可以染成红黑树，所有红黑树都是AVL树。</h3><p>错误。前半句正确，只需将高度为偶数的非根节点，染为红色，否则染为黑色。因为AVL的对于左右子树高度的平衡要求比红黑树更加严格，因此有些红黑树可能不满足AVL的要求。【该题存疑！】</p>
<h3 id="22、当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为："><a href="#22、当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为：" class="headerlink" title="22、当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为："></a>22、当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为：</h3><p>没有变化。RR1（叔父为黑）会改变O(1)的拓扑结构，但会立刻终止修正；而RR2（叔父为红）不会改变任何拓扑结构（而仅仅是将颜色重染），但可能会向上传递双红缺陷。</p>
<p>另一方面，对于删除操作，对于叔父节点、叔父节点的孩子、祖父的颜色共有四种情况，其中BB-1、BB-2R都是一蹴而就的，BB-3是两蹴而就的，只有BB-2B（叔父节点为黑、叔父节点的孩子均为黑、祖父为黑）的情况可能向上传递双黑缺陷；但只有BB-1和BB-3会改变拓扑结构，故而跟如20题所说，红黑树的插入、删除操作都不会使拓扑结构改变较大。</p>
<h3 id="23、伸展树单次查找操作的最坏时间复杂度比AVL树大。"><a href="#23、伸展树单次查找操作的最坏时间复杂度比AVL树大。" class="headerlink" title="23、伸展树单次查找操作的最坏时间复杂度比AVL树大。"></a>23、伸展树单次查找操作的最坏时间复杂度比AVL树大。</h3><p>正确。在单链伸展树中插入叶子元素，需要一直向上双层伸展（事实上双层伸展也是“逐层”伸展，只是顺序略有不同），此时复杂度为O(n)。</p>
<p>值得一提的是，在分摊分析的时候，我们为了避免这样的情况，将分摊时间记为A，其等于实际时间T与势能差delta的和。其中势能可以理解为“银行”，简单操作省下来的时间会“积德行善”地存入一些多余的时间，在遇到最坏情况时我们再将这些“存款”取出，用于弥补不足。如是便能均衡地“劫富济贫”，完成分析。每一步的A之和不大于每一步的T之和，而每一步的A均不超过log n（当T为θ(n)时，势能函数会为一个θ(n)级别的负数）。具体过程请见邓公编写的习题解析8-2。</p>
<h3 id="24、对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为："><a href="#24、对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为：" class="headerlink" title="24、对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为："></a>24、对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为：</h3><p>O(n)。假如我们粗略地估计时间复杂度，大概率得出的结论是O(m*n)…然而假如我们记录一个观察值k&#x3D;2 i - j，那么我们会发现无论是失败匹配还是成功匹配，其都会使得观察值k严格递增（至少加1），于是迭代过程至多不会超过2 n次，即时间复杂度为O(n)。（说是O(m+n)也行）</p>
<h3 id="25、有2015个节点的左式堆，左子堆的规模最小为？"><a href="#25、有2015个节点的左式堆，左子堆的规模最小为？" class="headerlink" title="25、有2015个节点的左式堆，左子堆的规模最小为？"></a>25、有2015个节点的左式堆，左子堆的规模最小为？</h3><p>1。事实上正如教材所说，左式堆的左子堆未必要比右子堆“大”很多，左子堆的规模和高度都不一定大于其兄弟，甚至可以夸张到本题的程度。本题的例子是根的左子堆只有一个节点，右子堆根节点只有左孩子，其左孩子亦只有左孩子…即每个节点的右侧链都只有其本身，这样每个节点的npl均等于其右侧链长度1。</p>
<h3 id="26、与MAD相比，除余法的缺陷在于："><a href="#26、与MAD相比，除余法的缺陷在于：" class="headerlink" title="26、与MAD相比，除余法的缺陷在于："></a>26、与MAD相比，除余法的缺陷在于：</h3><p>不动点和高阶均匀性（相关性）。不动点是指hash(0)&#x3D;0；高阶均匀性指相邻的关键码的地址一定相邻。而multipy-add-divide方法便不会有这些问题。</p>
<h3 id="27、将1、2、3…2018插入到一个空伸展树中，若最终树高为2017，则插入的次序一定是单调的。"><a href="#27、将1、2、3…2018插入到一个空伸展树中，若最终树高为2017，则插入的次序一定是单调的。" class="headerlink" title="27、将1、2、3…2018插入到一个空伸展树中，若最终树高为2017，则插入的次序一定是单调的。"></a>27、将1、2、3…2018插入到一个空伸展树中，若最终树高为2017，则插入的次序一定是单调的。</h3><p>错误。比如1，2，3，4，6，5，7，由于在7插入的时候会重新将splay tree变成单链，故诸如此类的操作仍然会形成单链。</p>
<h3 id="28、linearselect最坏复杂度为？"><a href="#28、linearselect最坏复杂度为？" class="headerlink" title="28、linearselect最坏复杂度为？"></a>28、linearselect最坏复杂度为？</h3><p>O(n)。事实上，见教材 P 1274，我们取一堆小子序列中位数的中位数，以此作为轴点来解决轴点选取过差的问题。（此时轴点至少能排除n&#x2F;4长度的差区间）我们得出如下公式：T(n)&#x3D; c n+ T(n&#x2F;Q) + T(3&#x2F;(4 n))。</p>
<h3 id="29、图的广度优先搜索访问各顶点的模式类似于二叉树的："><a href="#29、图的广度优先搜索访问各顶点的模式类似于二叉树的：" class="headerlink" title="29、图的广度优先搜索访问各顶点的模式类似于二叉树的："></a>29、图的广度优先搜索访问各顶点的模式类似于二叉树的：</h3><p>层次遍历。顺便一说，深度优先搜索类似于先序遍历。</p>
<h3 id="30、多叉堆比二叉堆的操作复杂度更高？"><a href="#30、多叉堆比二叉堆的操作复杂度更高？" class="headerlink" title="30、多叉堆比二叉堆的操作复杂度更高？"></a>30、多叉堆比二叉堆的操作复杂度更高？</h3><p>错误。事实上，上滤成本是降低至log d n，而（由于至多需要比对d个孩子）下滤成本会升高至d * log d n。当d约等于2+e&#x2F;n时，优先级搜索的效率会达到最优 e*log (2+e&#x2F;n) n。另一方面，d最好是2的次幂，否则不能直接借助移位操作来加快秩的计算。</p>
<h3 id="31、在理想随机下，quickselect（k-select）的复杂度及其证明？"><a href="#31、在理想随机下，quickselect（k-select）的复杂度及其证明？" class="headerlink" title="31、在理想随机下，quickselect（k-select）的复杂度及其证明？"></a>31、在理想随机下，quickselect（k-select）的复杂度及其证明？</h3><p>O(n)。我们记T(n)为期望比较次数，T(n) &lt;&#x3D; (n-1) + (2&#x2F;n)*( T(2&#x2F;n) + T(1+2&#x2F;n) + … + T(n-1) )，在此我们<strong>大胆猜测</strong>T(n)&lt; 4 n，归纳证明该结论是正确的。</p>
<h3 id="32、下图是一个三叉树实现的trie树，请写出其中储存的所有单词："><a href="#32、下图是一个三叉树实现的trie树，请写出其中储存的所有单词：" class="headerlink" title="32、下图是一个三叉树实现的trie树，请写出其中储存的所有单词："></a>32、下图是一个三叉树实现的trie树，请写出其中储存的所有单词：</h3><p><img src="/2023/04/02/dsa/593ec60e90487b413ecea3ed74aa70e.png"></p>
<p>（顺序无关）how many roads must a man walk down. </p>
<p>三叉trie树的左右孩子都是“另开炉灶”的，只有中孩子继承了父亲的字母，比如中间的must，u是m的中孩子，s是u的中孩子，t是u的中孩子，故而有must。而d是m的左孩子，故而d没有继承m，该单词为down而非mdown。</p>
<h3 id="33、在散列表中，一个好的散列函数h需要是单射？"><a href="#33、在散列表中，一个好的散列函数h需要是单射？" class="headerlink" title="33、在散列表中，一个好的散列函数h需要是单射？"></a>33、在散列表中，一个好的散列函数h需要是单射？</h3><p>错误。事实上不可能是单射，因为可用地址空间比所有词条的空间要小，所以一定会有多个词条映射到同一个地址。</p>
<h3 id="34、若某算法的时间复杂度递归式可写为T-n-x3D-2020-T-n-1-x2F-2020-O-log-n-，求其渐进复杂度。"><a href="#34、若某算法的时间复杂度递归式可写为T-n-x3D-2020-T-n-1-x2F-2020-O-log-n-，求其渐进复杂度。" class="headerlink" title="34、若某算法的时间复杂度递归式可写为T(n)&#x3D;2020 * T(n^(1&#x2F;2020)) + O(log n)，求其渐进复杂度。"></a>34、若某算法的时间复杂度递归式可写为T(n)&#x3D;2020 * T(n^(1&#x2F;2020)) + O(log n)，求其渐进复杂度。</h3><p>log n* log log n。本题的递归式不是主定理传统的n&#x2F;b，故而看起来我们对其无可奈何；但假如我们设m &#x3D; log n，那么原式变成T(n) &#x3D;R(m) &#x3D; 2020 * R(m&#x2F;2020) + O(m)，故而得出结论。</p>
<h3 id="35、请证明，如果表长为4k-3的素数，那么双向平方试探的确可以遍历所有地址空间。"><a href="#35、请证明，如果表长为4k-3的素数，那么双向平方试探的确可以遍历所有地址空间。" class="headerlink" title="35、请证明，如果表长为4k+3的素数，那么双向平方试探的确可以遍历所有地址空间。"></a>35、请证明，如果表长为4k+3的素数，那么双向平方试探的确可以遍历所有地址空间。</h3><p>首先，我们需要引入费马双平方引理及其推论，即一个自然数是两个整数的平方和当且仅当其4k+3形式的素因子的次数为偶数。如45&#x3D;5*3^2，其等于9+36。</p>
<p>我们首先易得，正向试探中0 – 2k+1的模是互异的，而2k+2 – 4k+3与其完全对称。简单来说，n^2-m^2能被该素数整除当且仅当n+m等于该素数。</p>
<p>然后我们证明，反向试探中0 – 2k+1（同上，是互异的）与正向试探除了0之外，模都是互异的。否则，n^2+m^2可以被该素数整除，但由费马双平方引理知其只能整除该素数的平方、四次方…而这显然是不可能的，因为n^2+m^2小于该素数平方。</p>
<p>由此证毕，正向试探共有2k+2个（算上0），而反向试探共有2k+1个。</p>
<h3 id="36、基于比较的排序算法，对于任何输入序列都需要至少Ω-n-log-n-时间。"><a href="#36、基于比较的排序算法，对于任何输入序列都需要至少Ω-n-log-n-时间。" class="headerlink" title="36、基于比较的排序算法，对于任何输入序列都需要至少Ω(n log n)时间。"></a>36、基于比较的排序算法，对于任何输入序列都需要至少Ω(n log n)时间。</h3><p>错误。正如第七题所说，插入排序是输入敏感的，其最好情况只需O(n)时间。</p>
<h3 id="37、在二叉树的先序、中序、后序遍历中，叶子节点的次序都是一样的。"><a href="#37、在二叉树的先序、中序、后序遍历中，叶子节点的次序都是一样的。" class="headerlink" title="37、在二叉树的先序、中序、后序遍历中，叶子节点的次序都是一样的。"></a>37、在二叉树的先序、中序、后序遍历中，叶子节点的次序都是一样的。</h3><p>正确。这是一个蛮有意思的小结论。</p>
<h3 id="38、基于二分查询A版本改进的fib查找，对于长度为n-x3D-fib-k-1的向量，最坏查找长度为？"><a href="#38、基于二分查询A版本改进的fib查找，对于长度为n-x3D-fib-k-1的向量，最坏查找长度为？" class="headerlink" title="38、基于二分查询A版本改进的fib查找，对于长度为n&#x3D;fib(k)-1的向量，最坏查找长度为？"></a>38、基于二分查询A版本改进的fib查找，对于长度为n&#x3D;fib(k)-1的向量，最坏查找长度为？</h3><p>k-1。可以用归纳证明：由于fib(k)-1左右区间分别为fib(k-1)-1和fib(k-2)-1，向左的最坏长度为k-2+1，向右的最坏长度为k-3+2，均为k-1。本题也体现了最坏情况下fib查找的均衡性。</p>
<h3 id="39、具有2020个内部节点的红黑树的最大黑高度是？"><a href="#39、具有2020个内部节点的红黑树的最大黑高度是？" class="headerlink" title="39、具有2020个内部节点的红黑树的最大黑高度是？"></a>39、具有2020个内部节点的红黑树的最大黑高度是？</h3><p>10。黑高度&#x3D;其等价B树的高度，其等于1+log m&#x2F;2 (N+1&#x2F;2)向下取整。另一方面，最大高度有些困难，我们试图让一个红黑树的高度等于其黑高度的二倍，并且用尽可能少的节点，故而我们只用h&#x2F;2个红色节点即可。后续计算相对麻烦，详见习题解析8-13。</p>
<h3 id="40、请证明：高度为h的AVL树，其叶子节点的深度不会小于h-x2F-2向上取整。"><a href="#40、请证明：高度为h的AVL树，其叶子节点的深度不会小于h-x2F-2向上取整。" class="headerlink" title="40、请证明：高度为h的AVL树，其叶子节点的深度不会小于h&#x2F;2向上取整。"></a>40、请证明：高度为h的AVL树，其叶子节点的深度不会小于h&#x2F;2向上取整。</h3><p><strong>对h做归纳</strong>（h&#x3D;1时显然）。假设以上命题对高度小于h的AVL 树均成立，以下考查高度为h的AVL树：</p>
<p>由于左、右子树的高度至多为h - 1，至少为h - 2，由归纳假设，高度h-1的叶子节点到该子树根的深度至少为(h-1)&#x2F;2向上取整，大于等于h&#x2F;2向上取整 -1；高度h-1的叶子节点到该子树根的深度至少为h&#x2F;2向上取整 -1。故而无论是h-1还是h-2，其叶子到总根节点的深度均不小于h&#x2F;2向上取整 -1 +1。证毕。</p>
<p><strong>本题体现了归纳法在树状结构（顺便一说，二分查找这类的证明题也可视作类树）中的出色发挥。</strong></p>
<h3 id="41、若将众数的定义改为“一半及一半以上的元素同为m，则m为众数”（原定义为：一半以上的元素同为m），课本P-1258的majCandidate算法是否还正确？"><a href="#41、若将众数的定义改为“一半及一半以上的元素同为m，则m为众数”（原定义为：一半以上的元素同为m），课本P-1258的majCandidate算法是否还正确？" class="headerlink" title="41、若将众数的定义改为“一半及一半以上的元素同为m，则m为众数”（原定义为：一半以上的元素同为m），课本P 1258的majCandidate算法是否还正确？"></a>41、若将众数的定义改为“一半及一半以上的元素同为m，则m为众数”（原定义为：一半以上的元素同为m），课本P 1258的majCandidate算法是否还正确？</h3><p>错误。虽然对于向量长度为奇数时，修改的定义显然与原定义没有区别，但对于向量长度为偶数时，我们很容易便能举出反例：0, 0, 0, 0, 1, 1, 1, 1, 2, 1。其中1是我修改定义后的众数，但算法会认为2是众数的候选者。本例中我们也能看到，算法选取的众数候选者甚至有可能是一个仅出现过一次的龙套元素。</p>
<h3 id="42、若T-n-x3D-O-n-2-，F-n-x3D-O-n-，则T-n-x2F-F-n-x3D-O-n-2-。"><a href="#42、若T-n-x3D-O-n-2-，F-n-x3D-O-n-，则T-n-x2F-F-n-x3D-O-n-2-。" class="headerlink" title="42、若T(n)&#x3D;O(n^2)，F(n)&#x3D;O(n)，则T(n)&#x2F;F(n)&#x3D;O(n^2)。"></a>42、若T(n)&#x3D;O(n^2)，F(n)&#x3D;O(n)，则T(n)&#x2F;F(n)&#x3D;O(n^2)。</h3><p>错误。事实上复杂度函数可以小于常数如F(n)&#x3D;θ(1&#x2F;n)，对于本课程而言请注意这种可能性的存在。</p>
<h3 id="43、在中缀表达式求值的时候，优先级表中有对应了非法表达式的空格项，列出所有这样的栈顶-x2F-当前运算符组合。"><a href="#43、在中缀表达式求值的时候，优先级表中有对应了非法表达式的空格项，列出所有这样的栈顶-x2F-当前运算符组合。" class="headerlink" title="43、在中缀表达式求值的时候，优先级表中有对应了非法表达式的空格项，列出所有这样的栈顶&#x2F;当前运算符组合。"></a>43、在中缀表达式求值的时候，优先级表中有对应了非法表达式的空格项，列出所有这样的栈顶&#x2F;当前运算符组合。</h3><p>“(“与”\0”、”)”与所有运算符、”\0”与”)”、”!”与”(“（其中第一个为栈顶运算符，第二个为当前运算符）。即左括号不可能留到最后而不遇到右括号；右括号不可能进入运算符栈；！是单目运算符，不可能直接与左括号相邻。</p>
<h3 id="44、为了实现”在2014个元素中挑选5个最大元素“的功能，在最坏情况下锦标赛树和二叉堆的比较次数相同吗？"><a href="#44、为了实现”在2014个元素中挑选5个最大元素“的功能，在最坏情况下锦标赛树和二叉堆的比较次数相同吗？" class="headerlink" title="44、为了实现”在2014个元素中挑选5个最大元素“的功能，在最坏情况下锦标赛树和二叉堆的比较次数相同吗？"></a>44、为了实现”在2014个元素中挑选5个最大元素“的功能，在最坏情况下锦标赛树和二叉堆的比较次数相同吗？</h3><p>不相同，后者是前者的二倍。与简单的上滤不同，<strong>每一步下滤需要和左右孩子都比较一番</strong>，而锦标赛树只需比较一次即可。</p>
<h3 id="45、规模为n的任何两棵等价二叉搜索树，至多经过2n-2-次旋转调整，即可彼此转换。"><a href="#45、规模为n的任何两棵等价二叉搜索树，至多经过2n-2-次旋转调整，即可彼此转换。" class="headerlink" title="45、规模为n的任何两棵等价二叉搜索树，至多经过2n - 2 次旋转调整，即可彼此转换。"></a>45、规模为n的任何两棵等价二叉搜索树，至多经过2n - 2 次旋转调整，即可彼此转换。</h3><p>正确。见习题解析7-15，将任意一棵”最左侧通路“长为s的（博主个人认为这东西几乎就是相对于npl右侧链的左侧链）二叉搜索树转换为一个左倾单链需要n-1-s步旋转。故而可知我们可以将树A先转为单链，再将单链反向转为树B，至多不会超过2n-2次旋转。</p>
<h3 id="46、对不含括号的中缀表达式求值时，操作符栈的容量可以固定为某一常数。"><a href="#46、对不含括号的中缀表达式求值时，操作符栈的容量可以固定为某一常数。" class="headerlink" title="46、对不含括号的中缀表达式求值时，操作符栈的容量可以固定为某一常数。"></a>46、对不含括号的中缀表达式求值时，操作符栈的容量可以固定为某一常数。</h3><p>正确。对于优先级表中除了左右括号和结束符&#x2F;0之外的操作符，当栈顶和当前运算符均为此操作符时，优先级均为栈顶&gt;当前，故而在不存在括号的情况下，操作符栈不可能堆叠大量运算符；在堆叠了各种不同的操作符后一定会执行运算并开始清楚栈中元素。</p>
<h3 id="47、带权重的最优PFC（前缀无歧义）编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。"><a href="#47、带权重的最优PFC（前缀无歧义）编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。" class="headerlink" title="47、带权重的最优PFC（前缀无歧义）编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。"></a>47、带权重的最优PFC（前缀无歧义）编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。</h3><p>正确。对于Huffman算法，若有出现频率相同的字符（或是在合并过程中存在出现频率相同的子树），则会有歧义的发生，这样的歧义虽不会导致Huffman树的最优性，却会导致不同结构的情况，这就是所谓Huffman树的不唯一性（另两个性质是内部节点的双子性和层次性）。至于题中所说的情况，abcd的出现频率分别是2211，这个简单的例子就可以构造出两棵高度不同的Huffman树。</p>
<h3 id="考后感想"><a href="#考后感想" class="headerlink" title="考后感想"></a>考后感想</h3><p>妈的，设计大题让设计一个括号匹配的数据结构。不会做，二十分白给，寄。</p>
<p>可能是因为判断题和简答题做的还不错（不过简答题第一题就不会，问的是教材中有些算法为了精简代码而牺牲了效率，根本没记）最后还是拿A-了，邓公太善良了T T</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Andy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/02/dsa/">http://example.com/2023/04/02/dsa/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Andy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://image.bliner.me/2018-12-13-15446748009361.png?imageView2/0/q/100|watermark/1/image/aHR0cDovL2ltYWdlLmJsaW5lci5tZS9ibGluZXJ3YXRlcm1hcmsucG5n/dissolve/40/gravity/SouthWest/dx/10/dy/10|imageslim" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/02/DLS1/" title="笛子的单恋史1--小张【1】"><img class="cover" src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">笛子的单恋史1--小张【1】</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/26/blog/" title="搭建个人网站的教程&amp;踩坑实录"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.740f2d36136b091fca6bf439b8043be3?rik=DfZ1XiYF3OWSiA&amp;riu=http%3a%2f%2fi1.3conline.com%2fimages%2fpiclib%2f201004%2f23%2fbatch%2f1%2f58538%2f127197858249656st9wgftr.jpg&amp;ehk=CwjaCS65ytVDcczEfkiMgBP74HAXFwChn3l0IEjOjw0%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">搭建个人网站的教程&amp;踩坑实录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Andy</div><div class="author-info__description">虽然世界被无聊填平 我还有台老唱机~</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%ACC%EF%BC%8C%E5%BD%93%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E7%9A%84%E9%95%BF%E5%BA%A6%E7%BC%A9%E5%B0%8F%E4%B8%BA0%E6%97%B6%EF%BC%8CV-lo-%E6%98%AF%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">1、对于二分查找版本C，当查找区间的长度缩小为0时，V[lo]是：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%9C%A8%E6%9C%89%E5%BA%8F%E5%90%91%E9%87%8FV%E4%B8%AD%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0e%E5%B9%B6%E4%BD%BF%E4%B9%8B%E4%BF%9D%E6%8C%81%E6%9C%89%E5%BA%8F%EF%BC%8C%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF"><span class="toc-number">2.</span> <span class="toc-text">2、在有序向量V中插入元素e并使之保持有序，下列代码正确的是:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%B0%86%E8%A7%86%E9%A2%91%E9%87%8C%E5%90%91%E9%87%8F%E6%89%A9%E5%AE%B9%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">3、是否可以将视频里向量扩容代码中的：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#for-int-i-0-i-lt-size-i-elem-i-oldElem-i"><span class="toc-number">3.0.1.</span> <span class="toc-text">for (int i &#x3D; 0; i &lt; _size; i++) _elem[i] &#x3D; oldElem[i];</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E4%B8%BA%EF%BC%9A"><span class="toc-number">3.0.2.</span> <span class="toc-text">替代为：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#memcpy-elem-oldElem-size-sizeof-T"><span class="toc-number">3.0.3.</span> <span class="toc-text">memcpy(_elem, oldElem, _size * sizeof(T));</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%94%A8%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E6%80%9D%E6%83%B3%E6%9D%A5%E8%A7%A3%E5%86%B3%E9%95%BF%E5%BA%A6%E4%B8%BAn%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88n%E8%B6%B3%E5%A4%9F%E5%A4%A7%EF%BC%89%EF%BC%8C%E9%80%92%E5%BD%92%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%95%B0%E7%9B%AE%E4%BC%9A%E6%AF%94%E7%94%A8%E5%87%8F%E8%80%8C%E6%B2%BB%E4%B9%8B%E7%9A%84%E6%96%B9%E6%B3%95%E5%B0%91%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">4、用分而治之的思想来解决长度为n的数组的求和问题（n足够大），递归实例的数目会比用减而治之的方法少。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%AE%9A%E4%B9%89%E4%BB%A5%E9%80%92%E5%BD%92%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AE%A1%E7%AE%97fib-n-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%CE%98-2-n-%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">5、直接用定义以递归的方式计算fib(n)的时间复杂度是Θ(2^n)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%9C%A8%E5%90%91%E9%87%8FV-x3D-2-3-5-7-11-13-17-19-23-%E4%B8%AD%E7%94%A8%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E6%90%9C%E7%B4%A2%E5%85%83%E7%B4%A07%EF%BC%8C%E7%8C%9C%E6%B5%8B%E7%9A%84%E8%BD%B4%E7%82%B9mi%E4%B8%BA%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">6、在向量V&#x3D;{2, 3, 5, 7, 11, 13, 17, 19, 23}中用插值查找搜索元素7，猜测的轴点mi为：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E9%95%BF%E5%BA%A6%E4%B8%BAn%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%8C%E8%A2%AB%E7%AD%89%E5%88%86%E4%B8%BAn-x2F-k%E6%AE%B5%EF%BC%8C%E6%AF%8F%E6%AE%B5%E9%95%BF%E5%BA%A6%E4%B8%BAk%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%AE%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%80%86%E5%BA%8F%E3%80%82%E5%AF%B9%E8%AF%A5%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">7、长度为n的列表，被等分为n&#x2F;k段，每段长度为k，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%EF%BC%88%E5%9C%A8%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%EF%BC%89%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E5%AE%9E%E9%99%85%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">8、（在中缀表达式求值中）什么时候进行实际的运算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%9C%A8%E4%B8%80%E6%A3%B5%E6%A0%91%E4%B8%AD-%E9%A1%B6%E7%82%B9p%E6%98%AF%E9%A1%B6%E7%82%B9v%E7%9A%84%E7%88%B6%E4%BA%B2-%E5%88%99%E5%AE%83%E4%BB%AC%E7%9A%84%E9%AB%98%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E4%B8%BAheight-v-x3D-height-p-1%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">9、在一棵树中,顶点p是顶点v的父亲,则它们的高度的关系是否为height(v)&#x3D;height(p)-1？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%AF%B9%E4%BB%A5%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E8%A1%8C%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E5%88%9A%E8%AE%BF%E9%97%AE%E5%AE%8C%E8%8A%82%E7%82%B9d%E6%97%B6%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B02%EF%BC%89%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%BB%8E%E6%A0%88%E9%A1%B6%E5%88%B0%E6%A0%88%E5%BA%95%E4%BE%9D%E6%AC%A1%E4%B8%BA"><span class="toc-number">10.</span> <span class="toc-text">10、对以下二叉树进行先序遍历，刚访问完节点d时（迭代实现2）栈中的元素从栈顶到栈底依次为:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%AF%B9%E4%BB%A5%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E8%A1%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E8%8A%82%E7%82%B9c%E5%88%9A%E8%A2%AB%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%AF%95%E6%97%B6%E6%A0%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%BB%8E%E6%A0%88%E9%A1%B6%E5%88%B0%E6%A0%88%E5%BA%95%E4%B8%BA"><span class="toc-number">11.</span> <span class="toc-text">12、对以下二叉树进行中序遍历，节点c刚被访问完毕时栈中的元素从栈顶到栈底为:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%AF%B9%E4%BB%A5%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E8%A1%8C%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%8C%E8%8A%82%E7%82%B9F%E6%AD%A3%E6%AC%B2%E5%87%BA%E9%98%9F%E6%97%B6%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E4%BB%8E%E9%98%9F%E5%A4%B4%E5%88%B0%E9%98%9F%E5%B0%BE%E4%B8%BA"><span class="toc-number">12.</span> <span class="toc-text">13、对以下二叉树进行层次遍历，节点F正欲出队时队列中的元素从队头到队尾为:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E4%BB%8En%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E8%8A%82%E7%82%B9u%E9%80%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%9C%B0%E4%B8%8A%E6%BA%AF%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-n-%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">14、从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，最坏时间复杂度为O(n)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81AVL%E6%A0%91%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9%E6%9C%80%E5%A4%9A%E4%BC%9A%E4%BD%BF%E5%A4%9A%E5%B0%91%E8%8A%82%E7%82%B9%E5%A4%B1%E8%A1%A1%EF%BC%9F%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%91%A2%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">15、AVL树插入节点最多会使多少节点失衡？删除节点呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81AVL%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9%E5%BC%95%E5%8F%91%E5%A4%B1%E8%A1%A1%EF%BC%8C%E7%BB%8F%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4%E5%90%8E%E9%87%8D%E6%96%B0%E5%B9%B3%E8%A1%A1%EF%BC%8C%E6%AD%A4%E6%97%B6%E5%8C%85%E5%90%AB%E8%8A%82%E7%82%B9g-p-v%E7%9A%84%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6"><span class="toc-number">15.</span> <span class="toc-text">16、AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E4%BC%B8%E5%B1%95%E6%A0%91%E9%87%87%E7%94%A8%E5%8F%8C%E5%B1%82%E4%BC%B8%E5%B1%95%E7%AD%96%E7%95%A5%EF%BC%8C%E5%8D%B3%E5%8F%AF%E9%81%BF%E5%85%8D%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E7%9A%84%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">17、伸展树采用双层伸展策略，即可避免最坏情况的发生？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E5%A6%82%E6%9E%9C%E8%AF%B4%E8%AE%BF%E9%97%AE%E4%B8%80%E6%AC%A1%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%811%E7%A7%92%EF%BC%8C%E5%88%99%E4%B8%80%E6%AC%A1%E5%A4%96%E5%AD%98%E8%AE%BF%E9%97%AE%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%EF%BC%9A"><span class="toc-number">17.</span> <span class="toc-text">18、如果说访问一次内存需要1秒，则一次外存访问大概需要：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E6%95%99%E6%9D%90P-802%E7%9A%84%E9%87%8D%E6%95%A3%E5%88%97%EF%BC%88rehash%EF%BC%89%E4%B8%80%E5%AE%9A%E6%98%AF%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">19、教材P 802的重散列（rehash）一定是扩容操作吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8%E6%AF%8F%E6%AC%A1%E6%8F%92%E5%85%A5-x2F-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E5%90%8E%EF%BC%8C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%98%E5%8C%96%E4%B8%8D%E8%B6%85%E8%BF%87O-1-%E3%80%82"><span class="toc-number">19.</span> <span class="toc-text">20、红黑树在每次插入&#x2F;删除操作后，拓扑结构的变化不超过O(1)。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E6%89%80%E6%9C%89AVL%E6%A0%91%E5%8F%AF%E4%BB%A5%E6%9F%93%E6%88%90%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%8C%E6%89%80%E6%9C%89%E7%BA%A2%E9%BB%91%E6%A0%91%E9%83%BD%E6%98%AFAVL%E6%A0%91%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">21、所有AVL树可以染成红黑树，所有红黑树都是AVL树。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E5%BD%93%E5%8F%94%E7%88%B6%E8%8A%82%E7%82%B9u%E4%B8%BA%E7%BA%A2%E8%89%B2%E6%97%B6%EF%BC%8C%E4%BF%AE%E6%AD%A3%E5%8F%8C%E7%BA%A2%E7%BC%BA%E9%99%B7%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E7%9A%84%E5%8F%98%E5%8C%96%E4%B8%BA%EF%BC%9A"><span class="toc-number">21.</span> <span class="toc-text">22、当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E4%BC%B8%E5%B1%95%E6%A0%91%E5%8D%95%E6%AC%A1%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94AVL%E6%A0%91%E5%A4%A7%E3%80%82"><span class="toc-number">22.</span> <span class="toc-text">23、伸展树单次查找操作的最坏时间复杂度比AVL树大。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E5%AF%B9%E4%BA%8E%E9%95%BF%E5%BA%A6%E4%B8%BAn%E7%9A%84%E6%96%87%E6%9C%AC%E4%B8%B2%E5%92%8C%E9%95%BF%E5%BA%A6%E4%B8%BAm%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%B2%EF%BC%8CKMP%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%EF%BC%9A"><span class="toc-number">23.</span> <span class="toc-text">24、对于长度为n的文本串和长度为m的模式串，KMP算法的时间复杂度为：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E6%9C%892015%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%B7%A6%E5%BC%8F%E5%A0%86%EF%BC%8C%E5%B7%A6%E5%AD%90%E5%A0%86%E7%9A%84%E8%A7%84%E6%A8%A1%E6%9C%80%E5%B0%8F%E4%B8%BA%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">25、有2015个节点的左式堆，左子堆的规模最小为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E4%B8%8EMAD%E7%9B%B8%E6%AF%94%EF%BC%8C%E9%99%A4%E4%BD%99%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="toc-number">25.</span> <span class="toc-text">26、与MAD相比，除余法的缺陷在于：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E5%B0%861%E3%80%812%E3%80%813%E2%80%A62018%E6%8F%92%E5%85%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E7%A9%BA%E4%BC%B8%E5%B1%95%E6%A0%91%E4%B8%AD%EF%BC%8C%E8%8B%A5%E6%9C%80%E7%BB%88%E6%A0%91%E9%AB%98%E4%B8%BA2017%EF%BC%8C%E5%88%99%E6%8F%92%E5%85%A5%E7%9A%84%E6%AC%A1%E5%BA%8F%E4%B8%80%E5%AE%9A%E6%98%AF%E5%8D%95%E8%B0%83%E7%9A%84%E3%80%82"><span class="toc-number">26.</span> <span class="toc-text">27、将1、2、3…2018插入到一个空伸展树中，若最终树高为2017，则插入的次序一定是单调的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81linearselect%E6%9C%80%E5%9D%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BA%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">28、linearselect最坏复杂度为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E8%AE%BF%E9%97%AE%E5%90%84%E9%A1%B6%E7%82%B9%E7%9A%84%E6%A8%A1%E5%BC%8F%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%EF%BC%9A"><span class="toc-number">28.</span> <span class="toc-text">29、图的广度优先搜索访问各顶点的模式类似于二叉树的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81%E5%A4%9A%E5%8F%89%E5%A0%86%E6%AF%94%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">30、多叉堆比二叉堆的操作复杂度更高？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81%E5%9C%A8%E7%90%86%E6%83%B3%E9%9A%8F%E6%9C%BA%E4%B8%8B%EF%BC%8Cquickselect%EF%BC%88k-select%EF%BC%89%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E5%85%B6%E8%AF%81%E6%98%8E%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">31、在理想随机下，quickselect（k-select）的复杂度及其证明？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E4%B8%8B%E5%9B%BE%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%89%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%9A%84trie%E6%A0%91%EF%BC%8C%E8%AF%B7%E5%86%99%E5%87%BA%E5%85%B6%E4%B8%AD%E5%82%A8%E5%AD%98%E7%9A%84%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%EF%BC%9A"><span class="toc-number">31.</span> <span class="toc-text">32、下图是一个三叉树实现的trie树，请写出其中储存的所有单词：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%9C%A8%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0h%E9%9C%80%E8%A6%81%E6%98%AF%E5%8D%95%E5%B0%84%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">33、在散列表中，一个好的散列函数h需要是单射？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E8%8B%A5%E6%9F%90%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%80%92%E5%BD%92%E5%BC%8F%E5%8F%AF%E5%86%99%E4%B8%BAT-n-x3D-2020-T-n-1-x2F-2020-O-log-n-%EF%BC%8C%E6%B1%82%E5%85%B6%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%82"><span class="toc-number">33.</span> <span class="toc-text">34、若某算法的时间复杂度递归式可写为T(n)&#x3D;2020 * T(n^(1&#x2F;2020)) + O(log n)，求其渐进复杂度。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81%E8%AF%B7%E8%AF%81%E6%98%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A1%A8%E9%95%BF%E4%B8%BA4k-3%E7%9A%84%E7%B4%A0%E6%95%B0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%8C%E5%90%91%E5%B9%B3%E6%96%B9%E8%AF%95%E6%8E%A2%E7%9A%84%E7%A1%AE%E5%8F%AF%E4%BB%A5%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E3%80%82"><span class="toc-number">34.</span> <span class="toc-text">35、请证明，如果表长为4k+3的素数，那么双向平方试探的确可以遍历所有地址空间。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AF%B9%E4%BA%8E%E4%BB%BB%E4%BD%95%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97%E9%83%BD%E9%9C%80%E8%A6%81%E8%87%B3%E5%B0%91%CE%A9-n-log-n-%E6%97%B6%E9%97%B4%E3%80%82"><span class="toc-number">35.</span> <span class="toc-text">36、基于比较的排序算法，对于任何输入序列都需要至少Ω(n log n)时间。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%AD%EF%BC%8C%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%AC%A1%E5%BA%8F%E9%83%BD%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E3%80%82"><span class="toc-number">36.</span> <span class="toc-text">37、在二叉树的先序、中序、后序遍历中，叶子节点的次序都是一样的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86%E6%9F%A5%E8%AF%A2A%E7%89%88%E6%9C%AC%E6%94%B9%E8%BF%9B%E7%9A%84fib%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%95%BF%E5%BA%A6%E4%B8%BAn-x3D-fib-k-1%E7%9A%84%E5%90%91%E9%87%8F%EF%BC%8C%E6%9C%80%E5%9D%8F%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6%E4%B8%BA%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">38、基于二分查询A版本改进的fib查找，对于长度为n&#x3D;fib(k)-1的向量，最坏查找长度为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81%E5%85%B7%E6%9C%892020%E4%B8%AA%E5%86%85%E9%83%A8%E8%8A%82%E7%82%B9%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%BB%91%E9%AB%98%E5%BA%A6%E6%98%AF%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">39、具有2020个内部节点的红黑树的最大黑高度是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E8%AF%B7%E8%AF%81%E6%98%8E%EF%BC%9A%E9%AB%98%E5%BA%A6%E4%B8%BAh%E7%9A%84AVL%E6%A0%91%EF%BC%8C%E5%85%B6%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%8D%E4%BC%9A%E5%B0%8F%E4%BA%8Eh-x2F-2%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4%E3%80%82"><span class="toc-number">39.</span> <span class="toc-text">40、请证明：高度为h的AVL树，其叶子节点的深度不会小于h&#x2F;2向上取整。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E8%8B%A5%E5%B0%86%E4%BC%97%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%94%B9%E4%B8%BA%E2%80%9C%E4%B8%80%E5%8D%8A%E5%8F%8A%E4%B8%80%E5%8D%8A%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%E5%90%8C%E4%B8%BAm%EF%BC%8C%E5%88%99m%E4%B8%BA%E4%BC%97%E6%95%B0%E2%80%9D%EF%BC%88%E5%8E%9F%E5%AE%9A%E4%B9%89%E4%B8%BA%EF%BC%9A%E4%B8%80%E5%8D%8A%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%E5%90%8C%E4%B8%BAm%EF%BC%89%EF%BC%8C%E8%AF%BE%E6%9C%ACP-1258%E7%9A%84majCandidate%E7%AE%97%E6%B3%95%E6%98%AF%E5%90%A6%E8%BF%98%E6%AD%A3%E7%A1%AE%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">41、若将众数的定义改为“一半及一半以上的元素同为m，则m为众数”（原定义为：一半以上的元素同为m），课本P 1258的majCandidate算法是否还正确？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81%E8%8B%A5T-n-x3D-O-n-2-%EF%BC%8CF-n-x3D-O-n-%EF%BC%8C%E5%88%99T-n-x2F-F-n-x3D-O-n-2-%E3%80%82"><span class="toc-number">41.</span> <span class="toc-text">42、若T(n)&#x3D;O(n^2)，F(n)&#x3D;O(n)，则T(n)&#x2F;F(n)&#x3D;O(n^2)。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E5%9C%A8%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%E4%B8%AD%E6%9C%89%E5%AF%B9%E5%BA%94%E4%BA%86%E9%9D%9E%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%A9%BA%E6%A0%BC%E9%A1%B9%EF%BC%8C%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%99%E6%A0%B7%E7%9A%84%E6%A0%88%E9%A1%B6-x2F-%E5%BD%93%E5%89%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%84%E5%90%88%E3%80%82"><span class="toc-number">42.</span> <span class="toc-text">43、在中缀表达式求值的时候，优先级表中有对应了非法表达式的空格项，列出所有这样的栈顶&#x2F;当前运算符组合。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E4%B8%BA%E4%BA%86%E5%AE%9E%E7%8E%B0%E2%80%9D%E5%9C%A82014%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%AD%E6%8C%91%E9%80%895%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E2%80%9C%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%9C%A8%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8B%E9%94%A6%E6%A0%87%E8%B5%9B%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0%E7%9B%B8%E5%90%8C%E5%90%97%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">44、为了实现”在2014个元素中挑选5个最大元素“的功能，在最坏情况下锦标赛树和二叉堆的比较次数相同吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81%E8%A7%84%E6%A8%A1%E4%B8%BAn%E7%9A%84%E4%BB%BB%E4%BD%95%E4%B8%A4%E6%A3%B5%E7%AD%89%E4%BB%B7%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%8C%E8%87%B3%E5%A4%9A%E7%BB%8F%E8%BF%872n-2-%E6%AC%A1%E6%97%8B%E8%BD%AC%E8%B0%83%E6%95%B4%EF%BC%8C%E5%8D%B3%E5%8F%AF%E5%BD%BC%E6%AD%A4%E8%BD%AC%E6%8D%A2%E3%80%82"><span class="toc-number">44.</span> <span class="toc-text">45、规模为n的任何两棵等价二叉搜索树，至多经过2n - 2 次旋转调整，即可彼此转换。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E5%AF%B9%E4%B8%8D%E5%90%AB%E6%8B%AC%E5%8F%B7%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E6%97%B6%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%A0%88%E7%9A%84%E5%AE%B9%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%9B%BA%E5%AE%9A%E4%B8%BA%E6%9F%90%E4%B8%80%E5%B8%B8%E6%95%B0%E3%80%82"><span class="toc-number">45.</span> <span class="toc-text">46、对不含括号的中缀表达式求值时，操作符栈的容量可以固定为某一常数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81%E5%B8%A6%E6%9D%83%E9%87%8D%E7%9A%84%E6%9C%80%E4%BC%98PFC%EF%BC%88%E5%89%8D%E7%BC%80%E6%97%A0%E6%AD%A7%E4%B9%89%EF%BC%89%E7%BC%96%E7%A0%81%E6%A0%91%E4%B8%8D%E4%BB%85%E6%9C%AA%E5%BF%85%E5%94%AF%E4%B8%80%E3%80%81%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E6%9C%AA%E5%BF%85%E7%9B%B8%E5%90%8C%EF%BC%8C%E7%94%9A%E8%87%B3%E6%A0%91%E9%AB%98%E4%B9%9F%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%AD%89%E3%80%82"><span class="toc-number">46.</span> <span class="toc-text">47、带权重的最优PFC（前缀无歧义）编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E5%90%8E%E6%84%9F%E6%83%B3"><span class="toc-number">47.</span> <span class="toc-text">考后感想</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/DLS20/" title="笛子的单恋史20--回忆【2】"><img src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笛子的单恋史20--回忆【2】"/></a><div class="content"><a class="title" href="/2023/04/03/DLS20/" title="笛子的单恋史20--回忆【2】">笛子的单恋史20--回忆【2】</a><time datetime="2023-04-03T02:19:28.764Z" title="发表于 2023-04-03 10:19:28">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/DLS19/" title="笛子的单恋史19--回忆【1】"><img src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笛子的单恋史19--回忆【1】"/></a><div class="content"><a class="title" href="/2023/04/03/DLS19/" title="笛子的单恋史19--回忆【1】">笛子的单恋史19--回忆【1】</a><time datetime="2023-04-03T02:14:19.900Z" title="发表于 2023-04-03 10:14:19">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/DLS18/" title="笛子的单恋史18--龙套A【3】"><img src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笛子的单恋史18--龙套A【3】"/></a><div class="content"><a class="title" href="/2023/04/03/DLS18/" title="笛子的单恋史18--龙套A【3】">笛子的单恋史18--龙套A【3】</a><time datetime="2023-04-03T02:11:43.739Z" title="发表于 2023-04-03 10:11:43">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/DLS17/" title="笛子的单恋史17--红雨【4】"><img src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笛子的单恋史17--红雨【4】"/></a><div class="content"><a class="title" href="/2023/04/03/DLS17/" title="笛子的单恋史17--红雨【4】">笛子的单恋史17--红雨【4】</a><time datetime="2023-04-03T02:09:40.048Z" title="发表于 2023-04-03 10:09:40">2023-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/03/DLS16/" title="笛子的单恋史16--红雨【3】"><img src="https://th.bing.com/th/id/R.a0b19a68c1bc77b6e0671b634156b9e4?rik=UYAlhdhg%2fd1GRw&amp;riu=http%3a%2f%2fimage.qianye88.com%2fpic%2f629d4ddf58e7978ea0309af374894a6c&amp;ehk=qSTVZAcbk4TA10p9yhfaRZlQV7yLIACbqRdzwIoCclU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笛子的单恋史16--红雨【3】"/></a><div class="content"><a class="title" href="/2023/04/03/DLS16/" title="笛子的单恋史16--红雨【3】">笛子的单恋史16--红雨【3】</a><time datetime="2023-04-03T02:07:52.711Z" title="发表于 2023-04-03 10:07:52">2023-04-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Andy</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>